// debugWire.cpp 

// Based on https://github.com/dcwbrown/dwire-debug/tree/master
//     other dWire code https://github.com/dwtk/dwtk/blob/master/debugwire/flash.go  


#define F_CPU (126150 * 128)   // or 18432000

#include <Windows.h>
#include <cstdint>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define COM_PORT "COM16"

#define windows
#define FileHandle FILE*
#define Assert(a) if (!(a)) printf("Assert! %s", a);
#define Fail(msg) printf(msg)

typedef uint8_t u8;
typedef uint16_t u16;
typedef int64_t s64;
typedef uint64_t u64;

HANDLE hCom;

void openSerial() {
	hCom = CreateFileA("\\\\.\\" COM_PORT, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, NULL, NULL);
	if (hCom == INVALID_HANDLE_VALUE) exit(-2);

	DCB dcb = { 0 };
	dcb.DCBlength = sizeof(DCB);
	dcb.BaudRate = F_CPU / 128;      // TODO: increase by changing divisor
	dcb.ByteSize = 8;
  dcb.StopBits = 0; // +1) /2
	dcb.fBinary = TRUE;
	if (!SetCommState(hCom, &dcb)) exit(-3);

  // GetCommState(hCom, &dcb);

	COMMTIMEOUTS timeouts = { 0 };  // in ms
	timeouts.ReadIntervalTimeout = 1; // between characters
	timeouts.ReadTotalTimeoutMultiplier = 1; // * num requested chars
	timeouts.ReadTotalTimeoutConstant = 1; // + this = total timeout
	if (!SetCommTimeouts(hCom, &timeouts)) exit(-4);
}

bool setBaudRate(int baud) {
  DCB dcb = { 0 };
	dcb.DCBlength = sizeof(DCB);
	dcb.BaudRate = baud;
	dcb.ByteSize = 8;
	dcb.fBinary = TRUE;
	return SetCommState(hCom, &dcb);
}

void commErrs() {
  while (1) {
    DWORD commErrors;
	  ClearCommError(hCom, &commErrors, NULL);
    switch (commErrors) {
      case 0 : return;
      case 0x08 : printf("Frame\n"); break;
      case 0x10 : printf("Break\n"); break;
      default : printf("CommErr %X ", commErrors); break;
    }
    Sleep(1);    
  }
}

int rxRdy() {
	COMSTAT cs;
	DWORD commErrors;
	if (!ClearCommError(hCom, &commErrors, &cs)) 
    return -1;
	return cs.cbInQue;
}

#define Wflush()

void Wc(char c) {
  printf("%c", c);
}

void Wd(s64 i, int w) {
  printf("%d", i);
}

void Ws(const char *s) {
  printf("%s", s);
}

void Wr(void) {
  Wc('\r');
}

void Wl(void) {
  Ws("\r\n");
}

void Wsl(const char *s) {Ws(s); Wl();}

void Wx(u64 i, int w) {
  printf("%X", i);
}

void SerialWrite(const u8 *bytes, int length) {
  WriteFile(hCom, bytes, length, NULL, NULL);
}

int SerialRead(u8 *buf, int len) {
  int totalRead = 0;
  do {
    DWORD lengthRead;
    ReadFile(hCom, buf + totalRead, len - totalRead, &lengthRead, NULL);
    if (lengthRead == 0) {
      printf("\nSerialRead expected %d bytes, got %d\n", len, totalRead); 
      if (totalRead) {Ws(":\n  "); for (int i=0; i<totalRead; i++) {Wx(buf[i], 2); Ws(" ");}}
      break;
    }
    totalRead += lengthRead;
  } while(totalRead < len);
  return totalRead;
}

void rxFlush(int index) {
  commErrs();
  u8 byte = 0xDE;
  DWORD length = 0;
  bool extras = false;
  while (1) {
    ReadFile(hCom, &byte, 1, &length, NULL);
    if (!length) 
      return;
    printf("%X! ", byte); // extra
    if (!extras) {
      extras = true;
      printf("@ %d  ", index);
    }
    Sleep(1);
  }
}

int echoErrors;

int SerialReadByte() {
  commErrs();
  u8 byte = 0;
  DWORD length;
  bool result = ReadFile(hCom, &byte, 1, &length, NULL);
  if (!result || length != 1) {
    Ws("-");
    return 0xDE;
  }
  return byte;
}

#if 1
void SerialSendBytes(const u8 *out, int outlen) {
  for (int b = 0; b < outlen; ++b) {
    rxFlush(b);
    WriteFile(hCom, out + b, 1, NULL, NULL);
    u8 echoed = SerialReadByte();
    if (echoed != *(out + b)) {
      printf("\nEcho %2X != %2X sent  ", echoed, *(out+b));
    }
  }
}

#else
void SerialSendBytes(const u8 *out, int outlen) {
  rxFlush(0);
  WriteFile(hCom, out, outlen, NULL, NULL);
  // Since TxD & RxD share the same wire, everything transmitted echos in the receive buffer (unless there is a collision). 
  // Drain echoed input and check that it is correct.
  u8 echoed[256];
  int totalRead = SerialRead(echoed, outlen);
  for (int i = 0; i < min(outlen, totalRead); i++) { 
    if (echoed[i] != out[i]) {
      Ws("Echo "); Wd(i+1,1); Ws(" of "); Wd(outlen,1);
      Ws(": Sent "); Wx(out[i],2); Ws(" got "); Wx(echoed[i],2); Wl();
      if (++echoErrors > 10) exit(3);
    }
  }
}
#endif

u8   SerialOutBufBytes[256];
int  SerialOutBufLength = 0;

void txFlush() {
  if (SerialOutBufLength > 0) {
    SerialSendBytes(SerialOutBufBytes, SerialOutBufLength);
    SerialOutBufLength = 0;
  }
}

int MaybeReadByte() {
  u8 byte = 0;
  DWORD bytesRead;
  bool res = ReadFile(hCom, &byte, 1, &bytesRead, NULL);
  if (bytesRead == 1) return byte; else return -1;
}


int GetSyncByte(struct SPort *sp, int verbose) {
  int byte  = 0;

  byte = MaybeReadByte();
  if (byte < 0) {
    Fail("Expecting break byte 0x00, but no bytes read.");
  }
  else if (byte != 0) {Ws("Warning, expected to read zero byte after break, but got $"); Wx((u8)byte,2); Fail(".");}

  if (verbose) Ws(", skipping [");
  if    (byte == 0)    {if (verbose) Wc('0'); byte = MaybeReadByte();} // Skip zero bytes generated by break.
  if    (byte == 0)    {if (verbose) Wc('0'); byte = MaybeReadByte();} // Skip zero bytes generated by break.
  if    (byte == 0)    {if (verbose) Wc(']'); return 0;}               // This many zeroes means we're very much faster than the chip
  while (byte == 0xFF) {if (verbose) Wc('F'); byte = MaybeReadByte();} // Skip 0xFF bytes generated by line going high following break.
  if (verbose) Ws("]");

  return byte;
}

void SerialSync() {
  u8 byte = 0;
  txFlush();

  int wait = 3;

  while (1) {
    switch (byte = SerialReadByte()) {
      case 0 :  // Eat 0x00 bytes generated by line at break (0v)
      case 0xFF : // Eat 0xFF bytes generated by line going high following break.
        continue;
      case 0x55 : return;

      case 0xDE : // wait
        if (--wait) {
          Sleep(16);
          continue;
        } // else error
     
      default : 
        printf("Got %X vs. 55 expected\n", byte);
        rxFlush(-1);
        return;
    }
  }
}

void SerialBreak(int period) {
if (period < 1) period = 1;

#ifdef windows
  SetCommBreak(hCom);
  // Sleep(period);
  ClearCommBreak(hCom);
#else
  ioctl(port, TCFLSH, TCIOFLUSH);
  ioctl(port, TIOCSBRK);
  usleep(period*1000);
  ioctl(port, TIOCCBRK);
#endif
  Sleep(1);
  SerialSync();
}




// Buffer accumulating debugWIRE data to be sent to the device to minimize
// the number of USB transactions used,

void SerialSend(const u8 *out, int outlen) {
#if 0
  SerialSendBytes(out, outlen); return;  // no buffer
#endif
  while (SerialOutBufLength + outlen >= sizeof(SerialOutBufBytes)) {
    // Total (buffered and passed here) meets or exceeds SerialOutBuf size.
    // Send buffered and new data until there remains between 0 and 127
    // bytes still to send in the buffer.
    int lenToCopy = sizeof(SerialOutBufBytes)-SerialOutBufLength;
    memcpy(SerialOutBufBytes+SerialOutBufLength, out, lenToCopy);
    SerialSendBytes(SerialOutBufBytes, sizeof(SerialOutBufBytes));
    SerialOutBufLength = 0;
    out += lenToCopy;
    outlen -= lenToCopy;
  }
  Assert(SerialOutBufLength + outlen <= sizeof(SerialOutBufBytes));
  memcpy(SerialOutBufBytes+SerialOutBufLength, out, outlen);
  SerialOutBufLength += outlen;
  // Remainder stays in buffer to be sent with next read request, or on a
  // txFlush call.
}


int SerialReceive(u8 *in, int inlen) {
  txFlush(); // output
  SerialRead(in, inlen);

  return inlen;
}


int deviceType = 10;

// Device specific characteristics

struct Characteristic {
  const char *name;
  int   signature;
  int   ioregSize;
  int   sramSize;
  int   eepromSize;
  int   flashSize;  // In bytes
  int   DWDR;       // DebugWIRE data register, aka MONDR - Monitor data register
  int   pageSize;   // In bytes
  int   boot;       // Lowest PC value giving boot section access
  int   bootflags;  // Where to find the boot sectore control flags, if any
  int   EECR;       // EEPROM control register index. EEDR and EEARL always follow directly.
  int   EEARH;      // EEPROM address high (doesn't exist on all devices)
} Characteristics[] = {
//  name             sig   io  sram eeprom flash  dwdr   pg  boot    bf eecr  eearh
  {"ATtiny13",    0x9007,  64,   64,   64,  1024, 0x2E,  32, 0x0000, 0, 0x1C, 0x00},
  {"ATtiny2313",  0x910a,  64,  128,  128,  2048, 0x1f,  32, 0x0000, 0, 0x1C, 0x00},

  {"ATtiny25",    0x9108,  64,  128,  128,  2048, 0x22,  32, 0x0000, 0, 0x1C, 0x1F},
  {"ATtiny24",    0x910B,  64,  128,  128,  2048, 0x27,  32, 0x0000, 0, 0x1C, 0x1F},

  {"ATmega48A",   0x9205, 224,  512,  256,  4096, 0x31,  64, 0x0000, 0, 0x1F, 0x22},
  {"ATtiny45",    0x9206,  64,  256,  256,  4096, 0x22,  64, 0x0000, 0, 0x1C, 0x1F},
  {"ATtiny44",    0x9207,  64,  256,  256,  4096, 0x27,  64, 0x0000, 0, 0x1C, 0x1F},
  {"ATmega48PA",  0x920A, 224,  512,  256,  4096, 0x31,  64, 0x0000, 0, 0x1F, 0x22},
  {"ATtiny441",   0x9215, 224,  256,  256,  4096, 0x27,  16, 0x0000, 0, 0x1C, 0x1F},

  {"ATmega88A",   0x930A, 224, 1024,  512,  8192, 0x31,  64, 0x0F80, 1, 0x1F, 0x22},
  {"ATtiny85",    0x930B,  64,  512,  512,  8192, 0x22,  64, 0x0000, 0, 0x1C, 0x1F},
  {"ATtiny84",    0x930C,  64,  512,  512,  8192, 0x27,  64, 0x0000, 0, 0x1C, 0x1F},
  {"ATmega88PA",  0x930F, 224, 1024,  512,  8192, 0x31,  64, 0x0F80, 1, 0x1F, 0x22},
  {"ATtiny841",   0x9315, 224,  512,  512,  8192, 0x27,  16, 0x0000, 0, 0x1C, 0x1F},
  {"ATmega8U2",   0x9389, 224,  512,  512,  8192, 0x31,  64, 0x0000, 0, 0x1F, 0x22},

  {"ATmega168A",  0x9406, 224, 1024,  512, 16384, 0x31, 128, 0x1F80, 1, 0x1F, 0x22},
  {"ATmega168PA", 0x940B, 224, 1024,  512, 16384, 0x31, 128, 0x1F80, 1, 0x1F, 0x22},
  {"ATmega16U2",  0x9489, 224,  512,  512, 16384, 0x31, 128, 0x0000, 0, 0x1F, 0x22},

  {"ATmega328P",  0x950F, 224, 2048, 1024, 32768, 0x31, 128, 0x3F00, 2, 0x1F, 0x22},
  {"ATmega328",   0x9514, 224, 2048, 1024, 32768, 0x31, 128, 0x3F00, 2, 0x1F, 0x22},
  {"ATmega32U2",  0x958A, 224, 1024, 1024, 32768, 0x31, 128, 0x0000, 0, 0x1F, 0x22},
  {0,                  0,   0,    0,    0,     0,    0,   0,      0, 0,    0}
};

struct Characteristic *CurrentCharacteristics() {
  if (deviceType < 0) Fail("No device connected");
  return Characteristics + deviceType;
}
const char *Name(void) {return CurrentCharacteristics()->name;}
int  IoregSize(void)   {return CurrentCharacteristics()->ioregSize;}
int  SramSize(void)    {return CurrentCharacteristics()->sramSize;}
int  EepromSize(void)  {return CurrentCharacteristics()->eepromSize;}
int  FlashSize(void)   {return CurrentCharacteristics()->flashSize;}   // In bytes
int  PageSize(void)    {return CurrentCharacteristics()->pageSize;}    // In bytes
int  DWDRreg(void)     {return CurrentCharacteristics()->DWDR;}
int  DWDRaddr(void)    {return CurrentCharacteristics()->DWDR + 0x20;} // IO regs come after the 32 regs r0-r31
int  DataLimit(void)   {return 32 + IoregSize() + SramSize();}
int  BootSect(void)    {return CurrentCharacteristics()->boot;}
int  BootFlags(void)   {return CurrentCharacteristics()->bootflags;} // 1 = in ext fuse, 2 = in high fuse
int  EECR(void)        {return CurrentCharacteristics()->EECR;}
int  EEDR(void)        {return EECR()+1;}
int  EEARL(void)       {return EECR()+2;}
int  EEARH(void)       {return CurrentCharacteristics()->EEARH;}
int  SPMCSR(void)      {return 0x37;} // SPMCSR is at the same address on all devices
int  AddrFlag(void)    {return (FlashSize() < 8192) ? 0x10 : 0;} // Flag to include when setting PC or BP high byte

enum {MaxFlashPageSize = 128, MaxFlashSize = 32768, MaxSRamSize = 2048};

void DwSend(const u8 out) {
  SerialSend(&out, 1);
}

void DwSend(const u8 *out, int outlen) {
  SerialSend(out, outlen);
}

int  DwReceive(u8 *in, int inlen) {
  return SerialReceive(in, inlen);
}

void DwSync(void) {
  SerialSync();
}

int DwReadByte(void) {u8 byte = 0; DwReceive(&byte, 1); return byte;}
int DwReadWord(void) {u8 buf[2] = {0}; DwReceive(buf, 2); return (buf[0] << 8) | buf[1];}

u8 hi(int w) {return (w>>8) & 0xff;}
u8 lo(int w) {return (w   ) & 0xff;}


void DwSetPC(u16 pc) {
  u8 SetPC[] = {0xD0, hi(pc) | AddrFlag(), lo(pc)};
  DwSend(SetPC, sizeof SetPC);
}
void DwSetBP(u16 bp) {
  u8 SetBP[] = {0xD1, hi(bp) | AddrFlag(), lo(bp)};
  DwSend(SetBP, sizeof SetBP);
}

void DwInst(u16 inst) {
  u8 instr[] = {0x64, 0xD2, hi(inst), lo(inst), 0x23};
  DwSend(instr, sizeof instr);
}

void DwIn(u8 reg, u16 ioreg)  {DwInst(0xB000 | ((ioreg << 5) & 0x600) | ((reg << 4) & 0x01F0) | (ioreg & 0x000F));}
void DwOut(u16 ioreg, u8 reg) {DwInst(0xB800 | ((ioreg << 5) & 0x600) | ((reg << 4) & 0x01F0) | (ioreg & 0x000F));}

void DwGetRegs(int first, u8 *regs, int count) {
  if (count == 1) {
    DwOut(DWDRreg(), first);
  } else {
    DwSend(0x66);
    DwSetPC(first);
    DwSetBP(first + count);
    const u8 StartRegRead[] = {0xC2, 1, 0x20};
    DwSend(StartRegRead, sizeof StartRegRead);
  }
  DwReceive(regs, count);
}

void DwSetReg(int reg, u8 val) {DwIn(reg, DWDRreg()); DwSend(val);}

void DwSetRegs(int first, const u8 *regs, int count) {
  if (count <= 3) {
    DwSend(0x64); // Set single step loaded instruction mode
    while (count > 0) {DwSetReg(first, *regs); first++; regs++; count--;}
  } else {
    DwSend(0x66);
    DwSetPC(first);
    DwSetBP(first + count);
    const u8 StartRegWrite[] = {0xC2, 5, 0x20};
    DwSend(StartRegWrite, sizeof StartRegWrite);
    DwSend(regs, count);
  }
}

void DwSetZ(u16 z) {DwSetRegs(30, (u8*)&z, 2);}

enum {SPMEN=1, PGERS=3, PGWRT=5, BLBSET = 9, RWWSRE=0x11, SIGRD = 0x21};


u8 ReadSPMCSR(void) {
  u8 spmcsr;
  DwSend(0x64);        // Set up for single step mode
  DwIn(30, SPMCSR());         // in r30,SPMCSR
  DwGetRegs(30, &spmcsr, 1);  // spmcsr := r30
  //Ws(" SPMCSR $"); Wx(spmcsr,2); Wsl(".");
  return spmcsr;
}


void RenableRWW(void) {
  if (BootSect()) {
    DwSetPC(BootSect());  // Set PC that allows access to all of flash
    DwSetReg(29, RWWSRE); // r29 := RWWSRE
    DwOut(SPMCSR(), 29);  // out SPMCSR,r29
    DwInst(0x95E8);       // spm
  }
}


void DwReadFlash(int addr, int len, u8 *buf) {
  int limit = addr + len;
  if (limit > FlashSize()) {Fail("Attempt to read beyond end of flash.");}
  while (addr < limit) {
    int length = min(limit-addr, 64);      // Read no more than 64 bytes at a time so PC remains in valid address space.
    DwSetZ(addr);                          // Z := First address to read
    DwSetPC(BootSect());                   // Set PC that allows access to all of flash
    DwSetBP(BootSect()+2*length);          // Set BP to load length bytes
    const u8 StartFlashRead[] = {0x66, 0xC2, 2, 0x20};
    DwSend(StartFlashRead, sizeof StartFlashRead);
    DwReceive(buf, length);
    addr += length;
    buf  += length;
  }
}


void EraseFlashPage(u16 a) { // a = byte address of first word of page
  Assert((a & (PageSize()-1)) == 0);

  u8 PageErase[] = {PGERS, lo(a), hi(a)};
  DwSetRegs(29, PageErase, sizeof PageErase); // r29 := op (erase page), Z = first byte address of page
  DwSetPC(BootSect());                       // Set PC that allows access to all of flash
  DwSend(0x64);                              // Set up for single step mode
  DwOut(SPMCSR(), 29);                       // out SPMCSR,r29 (select page erase)
  const u8 DoPageErase[] = {0xD2, 0x95, 0xE8, 0x33};
  DwSend(DoPageErase, sizeof DoPageErase); // SPM
  DwSync();
}


void LoadPageBuffer(u16 a, const u8 *buf) {
  u8 WriteNextPageBufferWord[] = {SPMEN, lo(a), hi(a)};
  DwSetRegs(29, WriteNextPageBufferWord, sizeof WriteNextPageBufferWord); // r29 := op (write next page buffer word), Z = first byte address of page
  DwSend(0x64);                       // Set up for single step mode
  const u8 *limit = buf + PageSize();
  while (buf < limit) {
    DwSetRegs(0, buf, 2); buf += 2;  // r0 := low byte, r1 := high byte
    DwSetPC(BootSect());             // Set PC that allows access to all of flash
    DwOut(SPMCSR(), 29);             // out SPMCSR,r29 (write next page buffer word)
    DwInst(0x95E8);                  // spm
    DwInst(0x9632);                  // adiw Z,2
  }
}

void ProgramPage(u16 a) {
  DwSend(0x66);
  u8 PageWrite[] = {PGWRT, lo(a), hi(a)};
  DwSetRegs(29, PageWrite, sizeof PageWrite); // r29 = op (page write), Z = first byte address of page
  DwSetPC(BootSect());                       // Set PC that allows access to all of flash
  DwSend(0x64);                       // Set up for single step mode
  DwOut(SPMCSR(), 29);                       // out SPMCSR,r29 (PGWRT)
  if (BootSect()) {
    DwInst(0x95E8);                          // spm
    while ((ReadSPMCSR() & 0x1F) != 0) {Wc('.'); Wflush();} // Wait while programming busy
  } else {
    const u8 SpmBreak[] = {0xD2, 0x95, 0xE8, 0x33};
    DwSend(SpmBreak, sizeof SpmBreak);   // spm and break
    DwSync();
  }
}


void ShowPageStatus(u16 a, const char *msg) {
  Ws("$"); Wx(a,4); Ws(" - $"); Wx(a+PageSize()-1,4);
  Wc(' '); Ws(msg); Ws(".                "); Wr();
}


void WriteFlashPage(u16 a, const u8 *buf) {
  // Uses r0, r1, r29, r30, r31

  u8 page[MaxFlashPageSize];
  Assert(PageSize() <= sizeof(page));

  RenableRWW();

  DwReadFlash(a, PageSize(), page);

  if (memcmp(buf, page, PageSize()) == 0) {
    ShowPageStatus(a, "unchanged");
    return;
  }

  int erase = 0;
  for (int i=0; i<PageSize(); i++) {
    if (~page[i] & buf[i]) {erase=1; break;}
  }

  if (erase) {
    ShowPageStatus(a, "erasing");
    EraseFlashPage(a);
  }

  memset(page, 0xff, PageSize());
  if (memcmp(buf, page, PageSize()) == 0) {
    return;
  }

  ShowPageStatus(a, "loading page buffer");
  LoadPageBuffer(a, buf);

  ShowPageStatus(a, "programming");
  ProgramPage(a);

  RenableRWW();
}


u8 pageBuffer[MaxFlashPageSize] = {0};

void WriteFlash(u16 addr, const u8 *buf, int length) {
  Assert(addr + length <= FlashSize());
  Assert(length >= 0);
  if (length == 0) return;

  u8 R[32];
  DwGetRegs(0, R, 2); // Cache R0 and R1

  int pageOffsetMask = PageSize()-1;
  int pageBaseMask   = ~ pageOffsetMask;

  if (addr & pageOffsetMask) {

    // buf starts in the middle of a page

    int partBase   = addr & pageBaseMask;
    int partOffset = addr & pageOffsetMask;
    int partLength = min(PageSize()-partOffset, length);

    DwReadFlash(partBase, PageSize(), pageBuffer);
    memcpy(pageBuffer+partOffset, buf, partLength);
    WriteFlashPage(partBase, pageBuffer);

    addr   += partLength;
    buf    += partLength;
    length -= partLength;
  }

  Assert(length == 0  ||  ((addr & pageOffsetMask) == 0));

  // Write whole pages

  while (length >= PageSize()) {
    WriteFlashPage(addr, buf);
    addr   += PageSize();
    buf    += PageSize();
    length -= PageSize();
  }

  // Write any remaining partial page

  if (length) {
    Assert(length > 0);
    Assert(length < PageSize());
    Assert((addr & pageOffsetMask) == 0);
    DwReadFlash(addr, PageSize(), pageBuffer);
    memcpy(pageBuffer, buf, length);
    WriteFlashPage(addr, pageBuffer);
  }

  Ws("                                       \r");

  // Restore cached registers R0 and R1
  DwSetRegs(0, R, 2);
}


u16 PC;
u8* FlashBuffer;

void LoadBinary(HANDLE CurrentFile) {
  DWORD length;
  ReadFile(CurrentFile, FlashBuffer, sizeof(FlashBuffer), &length, NULL);
  if (length == 0) Ws("File is empty.");

  Ws("Loading "); Wd(length,1); Wsl(" flash bytes from binary image file.");
  WriteFlash(0, FlashBuffer, length);
  PC = 0;
}

int getSignature() {  
  DwSend(0xF3);  // read signature

  u8 sig[2];
  SerialReceive(sig, sizeof sig);

  printf("Signature: ");
  for (int i=0; i < sizeof sig; ++i)
    printf("%X ", sig[i]);
  printf("\n");

  return ((int)sig[1] << 8) | sig[0];
}

const int NumRegs = 32; // acutally 32
u8 regs[NumRegs];

void readAllRegs() {
  DwSend(0x66);
  DwSend(0xE6);
  u8 resp;  
  SerialReceive(&resp, 1);

  u8 ReadRegs[] = {0xD0, 0, 0, 0xD1, 0, NumRegs, 0xC2, 1, 0x20};
  DwSend(ReadRegs, sizeof(ReadRegs));
  SerialReceive(regs, sizeof(regs));
}

void reset() {
  DwSend(7); // reset 
  DwSend(0);
  DwSend(0x55);
  SerialSync();
}


void setBaud() { // OK
  DwSend(0x83); // set baud, expect 0x55
  setBaudRate(F_CPU / 128);  
  SerialSync();
}

void setFastBaud() {
  DwSend(0x82); // set baud, expect 0x55
  // need finer control of timing to work?   TODO
  setBaudRate(F_CPU / 64);  
  SerialSync();
}


int main() {
  openSerial();

  while (1) {
    setBaudRate(F_CPU / 128);  

    txFlush();
    rxFlush(-2);
    SerialBreak(1);

    getSignature();

  #if 0 
    setFastBaud();
  #endif

    getSignature();
    getSignature();

    readAllRegs();  // fails to send byte D0 -- TODO: diagnose -- sometimes see 0x55 @ 1.1 MHz --> baud divisor changed!! *****
  
    reset();

    printf("\n");

    break;
  }

  WriteFlash(0x100, pageBuffer, 128);

}


#if 0   // writing SerialPB5

00 55 
F3 93 0B 
82 00 00..00  switch to 288000 baud
66 E6 18   55 F0 00 BF 46  baud switch??
D0 00 00 D1 00 20 C2 01 20  00 00 00 00 41 00 00 00 00 00 00 00 00 80 04 00 00 00 00 00 00 10 20 00 D0 00 94 00 03 00 46 02 read regs
07 00 
C6 C6 
30 AD E0 00 01 86 A00000A1004082014000000000810000000000000000000C000000000000204000B000340003008602A00000A100408682054000000000810000000000000000000C000000000000204000A00034000300860280A00000700066E61E1E78061855F3930BF000BF46
D00000
D10020C20120000000004100000000000000008004000000000000102000
D0009400050046020700C6CE38B5E000018EA00000A10040820140000000008100000000000000000004000000000000204000B0002C000
D008602A0003EA10040868205400002A000008202A1000040C139FE8F3F7B1E73C03A39470
D631025F834FF8F1A12A3C5F2
D9C1
DC40A082654072617261677A61701A005A525A5A4A5A4A5A525A524A5A4A5A525A5A4A5A52A0003EA1004086820
D408002A000008202A10000405A5A4A5A000051E740B
D5A7318E059B
D412376E76131613320028A010080BC01FC01C75FF121EF43C1F762370480FC21C
D23F003C2215E377F0798E30825C139A0FE00A0003EA100408E820540A700A000008200A100024000A0003AA1004086820D40

030105400000A0FE00A2019F438EA27F4743A225D863
00C6C630B58CA0FE00A26402431EA264224380B27F6743A225
D043A22E6243A0FE00A26C024350A264224380A27F6743A22D
D843A2266243A0FE00A264024305A264224380A27F6743A235
D843A22E7243A0FE00B26402434EA26C224380A27F6743A225
D043A22E6243A0FE00A264024345A26C224380A27F6743A22D
C843A2266243A0FE00A264024344A264224380A27F6F43A225
D843A2266243A0FE00A264024343A26C224380A27F6F43A225
D843A2266243A0FE00A264024342A264224380A27F6743A22D
D843A2266243A0FE00A264024341A264224380A27F6743A22D
D843A2266243A0FE00A26C024340A26C324380A27F6743A225
D843A2266243A0FE00A26402433FA264224380A27F6F43A225
D843A22E6243A0FE00A27402433EA274224380A27F6743A22D
C843A22E6243A0FE00A2640243A0A264224380A27F6743A22D
C843A22E6243A0FE00A26402433CA26C324380A27F6743A225
D843A2266243A0FE00A264024333A26C224380A27F6743A225
D043A2266243A0FE00A274024321A274224344A27F6743A22D
C843A2266243A0FE00A26402433FA26422437EA27F6743A22D
D843A2266243A0FE00B26402439FA26C2243C5A27F6743A225
D043A22E6243A0FE00A26C0243A2A2642243C0A27F6F43A22D
C843A22E6243A0FE00A2640243BEA26422437FA27F6743A22D
D843A2266243A0FE00A26402439DA26C22437FA27F6743A225
D843A2266243A0FE00A264024320A26C2243C0A27F6743A225
D043A22E6243A0FE00A26C024340A2642243CEA27F6743A225
D043A2266243A0FE00A264024360B2642243C0B27F6743A235
D843A22E6243A0FE00A2640243CCA2642243C1A27F6743A225
D043A2266243A0FE00A2640243E2A2642243C0A27F6F43B225
D843A2266243A0FE00A264024302A264224380A27F6F43A225
D843A22E6243A0FE00A264024305A264224320B27F6743A225
D043A2266243A0FE00A26C02431DA26C224322A27F6743A225
D043A2266243A0FE00A26C02434CA264224379A27F6F43A225
D843A22E6243A0FE00A26C024361A26C22430FA27F6743A225
D043A2266243A0FE00A26C0243B9A26C2243EFA27F6743A22D
C843A2266243A0FE00A201FC43A27F8743A225D0
6300CEC638ADA0FE00A2C18143A27F8F43A225D06300C6C630ADA0003EA100408E820D40B700A10003A000
018682044000A0FE00A0003EA1004086820D40AF00A000008200A100024000A0003AA100408E820540
030105408000A0FE00A2019F4386A27F4743A225D863
00C6C638B584A0FE00A264024340A26C2243C0A27F6F43A225
D043A2266243A0FE00A26C024344A26C2243D1A27F6743A22D
C843A2266243A0FE00A274024360A2642243C0A27F6743A225
D043A2266243A0FE00A264024301A264224380A27F6743A22D
D843A2266243B0FE00A26402433DA264224322A27F6743A225
D043A2266243A0FE00A264024346A264224379A27F6743A235
D043B2266243A0FE00B264024362B26422430FA27F6743A225
D043A22E6243A0FE00A2640243C1A2642243E7A27F6743A22D
C843A22E6243A0FE00A264024302A2642243A0A27F6743A225
D043A22E6243A0FE00A26C0243BEA26C224380A27F6743A225
D043A22E6243A0FE00A2740243A5A26422438FA27F6F43A225
D043A2266243A0FE00A264024300A2642243C6A27F6F43A225
D043A2266243B0FE00A26C024320B2642243C0B27F6743A225
D843A2266243A0FE00A26C02438CA26C2243A0A27F6743A225
D043A2266243A0FE00A264024307A2642243C7A27F6743A22D
D843A2266243A0FE00A264024320A26C2243C0A27F6743A225
D043A22E6243A0FE00A274024381A2742243A0A27F6743A22D
D843A2266243A0FE00A264024300A2642243C2A27F6F43A225
D043A2266243A0FE00A26C024305A26422437FA27F6743A225
D043A22E6243A0FE00A26C0243F8A264224324A27F6743A225
D043A22E6243A0FE00A27402430FA274224363A27F6743A225
D843A22E6243A0FE00A264024302A2642243C0A27F6743A22D
C843A2266243A0FE00A26C024307B264224373B27F6743A235
D843A22E6243A0FE00A26C02431AA2642243DFA27F6F43A225
D043A2266243A0FE00A264024320B2642243C0A27F6F43A225
D043A22E6243A0FE00A26402430DA26C2243A0A27F6743A225
D043A22E6243A0FE00A26C024302A2642243C0A27F6743A22D
D843A2366243A0FE00A264024306A26422437BA27F6F43A225
D043A2266243A0FE00A2640243FAA26422439FA27F6F43B225
D843A2366243A0FE00A264024300A2642243C0A27F6743A22D
D843A2266243A0FE00A264024320A2642243C0A27F6743A22D
D843A2266243A0FE00A264024380A2642243A0A27F6743A225
D043A2266243A0FE00A201FC43A27F8F43A225D0
6300C6C638A5A0FE00A2C18143A27F8743B225D86300CEC638A5A0003EA1004086820540AF00A10003A000
0186820C4000A0FE00A0003EA1004086820540AF00A000008200A100024000A00032A1004086820540
030105400000A0FE00A2018F4386A27F4743A22DD863
00CEC638A584A0FE00A26C02431FA26C22437FA27F6743A235
D843A22E7243A0FE00B264024311A2642243E0A27F6F43A225
D843A22E6243A0FE00A264024301A26C22437FA27F6743A225
D043B2266243A0FE00A26C024318A26C224363A27F6743A225
D043A2266243A0FE00A26C024301A2642243C0A27F6743A225
D843A2266243A0FE00A264024318A264224373A27F6743A22D
C843A22E6243A0FE00A264024307A264224363A27F6743A22D
C843A2366243A0FE00A264024301A2642243C0A27F6743A225
D843A2266243A0FE00A26C024307A26C22437BA27F6743A225
D043A22E7243A0FE00A26C024310A274224325A27F6F43A225
D043A2266243A0FE00A264024333A26422436FA27F6F43A225
D843A2266243A0FE00A26402433FA2642243FDA27F6F43A225
D043A2266243A0FE00A26402433BA26422437FA27F6743A22D
D843A2266243A0FE00A26402431AA264224360A27F6F43A22D
C843A22E6243A0FE00A264024321A2642243E0A27F6F43A225
D843A2266243A0FE00A264024300A264224362B27F6743A225
D043A2266243A0FE00A26C024339A2642243ECA27F6743A225
D843A2266243A0FE00A264024331A2642243C0A27F6F43B225
D843A2266243A0FE00A264024320A264224323A27F6743A22D
C843A2266243A0FE00A264024325B264224300B27F6743A235
D843A2266243A0FE00A26C024320A26C2243C0A27F6743A225
D043A22E6243A0FE00A264024308A26422431FA27F6743A22D
D843A2266243A0FE00A264024339A26422433FA27F6F43A225
D043A2266243A0FE00A264024310A26C22431FA27F6743A22D
C843A22E6243A0FE00A264024339A26422433FA27F6743A22D
C843A22E6243A0FE00A264024301A26C2243C0A27F6743A235
D043A2266243B0FE00A26C024324A2642243C0A27F6743A225
D843A22E6243A0FE00A26402433CA264224301A27F6F43A225
D843A22E6243A0FE00A264024365A26C224325A27F6743A225
D043A22E6243A0FE00A264024347A26422432DA27F6F43A225
D843B2266243A0FE00A264024302A264224347A27F6743A22D
D843A2266243A0FE00A264024323A264224347A27F6F43A225
D043A22E7243A0FE00A201FC43A27F8743A22DD8
6300C6C638A5B0FE00B2C18143A27F8F43A225D86300C6C638A5A0003EA1004086820D40A700B10003A000
018E820C4000A0FE00A0003EB1004086820540AF00A000008200A100024000A00032A100408E820540
030105408000A0FE00A2019F4386A27F4743A225D863
00C6C630A584A0FE00A26C02434FB264224363B27F6743A225
D043A2266243A0FE00A264024341A2642243C0A27F6743A225
D043A2266243A0FE00A26C024347A26422437BA27F6743B225
D843A2266243A0FE00A26402434AA2642243C0A27F6F43A225
D043A2266243A0FE00A26C024378A26C22435FA27F6743A225
D043B2266243A0FE00A26C024361A26C2243E0A27F6743A225
D843A22E6243A0FE00A264024376A26422437BA27F6F43B225
C843A2266243A0FE00A264024325A264224325A27F6F43A225
D043A2266243A0FE00A264024307A26C324325A27F7743A225
D043A2266243A0FE00A264024364A2642243C0A27F6743A225
D043A2266243A0FE00A26C02437AA26422432DA27F6743A235
D043A22E7243A0FE00A2640243E1A2642243EFA27F6743A225
D843A2266243A0FE00A264024341A2642243A0A27F6743A22D
C843A22E6243A0FE00A264024361A2642243E7A27F6743A225
D043A2266243A0FE00A26402430FA264224363A27F6F43B225
D843A2366243A0FE00A26402431EA2642243FFA27F6743A225
D043A2266243A0FE00A264024307A26C224373B27F6743A235
D843A22E7243A0FE00A264024318A26C224325A27F6743A225
D043A2266243A0FE00A26C02439FA26C224323A27F6743A225
D043B2266243A0FE00A26C0243BFA26C224323A27F6743A225
D043A22E6243A0FE00A26C0243DCA26C224301A27F6743A225
D043A22E7243A0FE00A26C024378A26C22433BA27F6743A22D
D043A2266243A0FE00A264024386A2642243BFA27F6743A225
D043A2266243A0FE00A264024300A264224321A27F6F43A225
D043A2266243A0FE00A264024325A26C224300A27F6743A225
D043B2266243A0FE00A26C024301A26C224321A27F6743A225
D843A22E6243A0FE00A264024302A264224380A27F6743A225
D043A22E7243A0FE00A26C024300A26C2243C2A27F6743A225
D043A22E6243A0FE00A26402439DA2642243BFA27F6743A22D
C843A22E6243A0FE00A274024320A264224322A27F6F43A22D
C843A22E6243A0FE00A26402432DA264224300A27F6743A22D
D843A2266243A0FE00A26C024318A26C324301A27F6743A22D
D843A2266243A0FE00A201FC43A27F8743A22DC8
6300C6C638A5A0FE00B2C18143A27F8743A225D86300C6C630A5A0003EA100408E820540A700A10003A000
018682044000A0FE00A0003EA1004086820D40A700A000008200A100024000A00032A1004086820540
030105400001A0FE00A2018F4386A27F4743A225D063
00C6C630AD84A0FE00A26C024318A26C224343A27F6743A225
D043A2266243A0FE00A264024331A2642243E0A27F6F43A225
D043A2266243A0FE00A264024341A264224326A27F6743A225
D043A2266243A0FE00A264024386A2642243BFB27F6743A225
D043A2266243A0FE00A26C0243FAA26C22439FA27F6743A22D
D843A2266243A0FE00A26C0243BFB264224321B27F6743A235
D843A22E6243A0FE00A26C02439FA26C224321A27F6743A225
D043A2266243A0FE00B264024318A26C324325B27F7743A225
D843A2266243A0FE00A26C02433FA26C224322A27F6743A225
D043A22E6243A0FE00A26C02431FA26C224322A27F6743A225
D043A22E6243A0FE00A26C02431FA26422436EA27F6F43A225
D043A2266243A0FE00A26402431FA26C324322A27F6743A235
D843A2266243A0FE00A26C024321A264224344A27F6743A22D
D043A2266243A0FE00A26402435FA274224323A27F6F43A225
D843B2266243A0FE00A26402437FA264224323A27F6F43A225
D843A22E6243A0FE00A26402431FA264224323A27F6743A22D
D843A2266243A0FE00A26C02433FA264224323A27F6743A225
D843A22E6243A0FE00A26402434CA2642243C0A27F6743A22D
D843A2366243A0FE00A264024352A26C224325A27F6743A225
D843A2266243A0FE00A2640243E1A2642243EFA27F6F43A22D
C843A22E6243A0FE00A264024370A2642243C0A27F6743A22D
C843A22E6243A0FE00A264024346A26C224363A27F6743A235
D843A2266243A0FE00A26C024341A2642243E0A27F6743A225
D843A2266243A0FE00A26C024322A264224353A27F6743A235
D843A22E7243A0FE00A26402432EA26422432DA27F6F43A225
D843A2266243A0FE00A264024307A26C224325A27F6743A225
D843B22E7243A0FE00A26C024344A2642243C0A27F6743A22D
C843A22E6243A0FE00A26402435AA264224325A27F6743A235
D843A2266243A0FE00B2640243E1A26C2243E7A27F6743A225
D843A2266243A0FE00A264024361A2642243A0A27F6743A22D
C843A22E6243A0FE00A264024361A2742243EFA27F6F43A225
D843A22E6243A0FE00A264024300A264224323A27F6F43A225
D043A2266243A0FE00A201FC43B27F8743A235D8
6300C6C638B5A0FE00A2C18143B27F8743A235D86300C6CE38ADA0003EA1004086820540AF00A10003A000
018E82044000A0FE00A0003EA1004086820540A700A000008200A100024000A0003AA1004086820540
03010D408001A0FE00A2019F438EA27F4743A225D063
00CEC638AD8CA0FE00A26402432CA264224300A27F6743A225
D843A22E6243A0FE00A26C024300A2742243C2A27F6F43A225
D043A2266243A0FE00A264024312A26422437FA27F6F43A225
D043A2266243A0FE00A26402433FA264224331A27F6F43A22D
C843A2266243A0FE00A26402431FA264224321A27F6F43A22D
C843A2266243A0FE00A26402437FA264224331A27F6743A22D
D843A2266243A0FE00A26402435FA264224321A27F6743A225
D843A22E6243A0FE00A26C02431FA26C224320A27F6743A235
D843A22E7243A0FE00A26C02431FA26C22437EA27F6743A225
D843A22E6243A0FE00A26402431FA264224320A27F6F43A225
D843B2266243A0FE00A26C02433FA264224320A27F6743A22D
C843A22E6243A0FE00A264024338A264224335A27F6743A22D
D843A2366243A0FE00A26402433CA264224301A27F6743A22D
D843A2266243A0FE00A264024341A2642243A0A27F6743A225
D043A22E6243A0FE00A26C024361A26C224319A27F6743A225
D043A22E6243A0FE00A26C024311A26C22435BA27F6743A22D
D843A2366243A0FE00A264024349A2642243E0A27F6743A225
D843A2266243A0FE00A26C024305A26C2243C0A27F6743A235
D043A2266243B0FE00A26C02431AA26C22432DA27F6743A225
D843A2266243A0FE00A2640243E1A2642243EFA27F6743A225
D843A22E6243A0FE00A274024391A264224301A27F6F43A225
D843A22E6243A0FE00A2640243E6A26422439FA27F6743A22D
D843A22E6243A0FE00A264024310A274224325A27F6743A22D
C843A22E6243A0FE00A264024300A2642243C2A27F6F43A22D
D843A2266243A0FE00B264024305B26422437FA27F6F43A225
D843A2266243A0FE00A2640243F0A26C224324A27F6743A225
D043A22E6243A0FE00A264024348A264224325A27F6743A22D
D843A2266243A0FE00A26C024300A26C2243DDA27F6743A22D
D843A2267243A0FE00B264024301A26422437DB27F6743A225
D843A22E6243A0FE00A264024318A264224325A27F6F43A225
D043A2266243A0FE00A26C024310A26C224325A27F6743A225
D843A2266243A0FE00A26402439FA26C224323A27F6743A22D
C843A22E6243A0FE00A201FC43B27F8743A235D8
6300CEC638ADA0FE00A2C18143A27F8743A225D86300C6C638A5A0003EA1004086820540A700A10003A000
0186820C4000A0FE00A0003EA1004086820D40A700A000008200A100024000A0003AA1004086820540
030105400001A0FE00A2019F438EA27F4F43A225D063
00C6C630B584A0FE00A2640243BFA264224323A27F6743A225
D043B2266243A0FE00A26C0243DCA264224301A27F6743A225
D843A22E6243A0FE00A26C024300A26422436CA27F6F43A225
D043B22E7243A0FE00A264024321A26422430DA27F6743A225
D043A2266243A0FE00A264024360A2642243ECA27F6743A22D
D843A22E7243A0FE00B264024300A2642243C0A27F6743A225
D043A22E6243A0FE00A26C02433CA26C22435FA27F6743A225
D043B2267243A0FE00B264024339A26C32431FA27F6743A225
D043A2266243A0FE00A264024339A26C22431FA27F6743A22D
D843A2266243A0FE00A26C0243C2A26C2243BFA27F6743A225
D843A2266243A0FE00A26C024311A26C224380A27F6743A225
D043A22E7243A0FE00B2640243A2A26C224325A27F6743A225
D043A22E6243A0FE00A264024382A26422432DA27F6F43A225
D843A2266243B0FE00A26C02439FA26C3243E0A27F6743A225
D043A2266243A0FE00A26C02439DA26422434FA27F6743A225
D043A22E6243A0FE00A2740243BFA2742243E0A27F6743A22D
D843A2266243A0FE00A26402439DA264224347A27F6743A225
D843A22E6243A0FE00A2640243C5B2642243BFA27F6743A22D
D843A2266243A0FE00A26C024341A264224327A27F6743A22D
D843A2266243A0FE00A26C0243D9A2642243EFA27F6F43A225
D843A2266243A0FE00A2640243BFA264224321A27F6F43A225
D043A2266243A0FE00A26402439FA264224321A27F6F43A225
D843A2266243A0FE00A264024310A264224325A27F6743A22D
D043A2266243A0FE00A26C024358B26422432DA27F6F43A225
D043A22E6243A0FE00A26C02432CA26C22437EA27F6743A225
D843A2266243A0FE00A264024308A2642243C1A27F6F43B225
D843A2266243A0FE00A264024301A26C22437DA27F6743A225
D043A2266243A0FE00A26C024321A26C22437CA27F6743A225
D043A22E7243A0FE00A26C024318A26422432DA27F6F43A225
D843A2266243A0FE00A26402433FA264224322B27F6743A235
D843A2266243A0FE00A26402431FA26C224322A27F6743A225
D843A2266243A0FE00A26402431FA264224376A27F7743A225
D843A2266243A0FE00A201FC43A27F8743A225D8
6300C6C638ADA0FE00A2C18143A27F8743A22DC86300C6C638A5A0003EA1004086820D40A700B10003A000
0186820C4000A0FE00A0003EA1004086820540A700A000008200A100024000A00032A1004086820540
03010D408001A0FE00A2019F4386A27F4743A225D073
00C6C630B584A0FE00A26C02431FA26C224322A27F6743A235
D843A22E6243A0FE00A26C024321A26C224344A27F6743A225
D043A2266243A0FE00A26402435FB264224323B27F6743A225
D043B2266243A0FE00A26402437FA26C224323A27F6743A225
D043A2266243A0FE00A26402438FB264224323A27F6F43A225
D043B2266243A0FE00A26C0243BFA26C224323A27F6743A225
D043A2266243A0FE00A2640243DFA264224323A27F6F43B225
D843A2366243A0FE00A2640243FFA264224323A27F6743A22D
C843A22E6243A0FE00A26402431FA264224333A27F6743A22D
D843A2366243A0FE00A26C02433FA26C224323A27F6743A225
D843A22E6243A0FE00A26C02435FA26C224323A27F6743A225
D043A22E7243A0FE00A26C02437FA26C224323A27F6743A225
D043A22E6243A0FE00A2640243DFA26C224323A27F6743A22D
D843A2366243A0FE00A2640243FFA264224323A27F6743A22D
D043A2266243A0FE00A2640243D8A26C2243BFA27F6743A235
D843A2266243A0FE00B26C0243FFA264224321A27F6743A225
D043A22E6243A0FE00A26C0243DFA26C224321A27F6743A225
D843A22E6243A0FE00A26402437FA264224321A27F6743A22D
D843A22E6243A0FE00A26C02435FA26C224321A27F6743A22D
D843B2266243A0FE00A26402433FA274224321A27F6743A22D
D843A2266243A0FE00A26402430FA264224321A27F6743A225
D043A22E7243A0FE00A2640243FFA26C224321A27F6743A225
D043A22E6243A0FE00A26C0243DFA264224321A27F6F43A225
D843A2266243A0FE00A2640243BFA264224321A27F6743A22D
D843A2266243A0FE00A26402438FA264224321A27F6743A22D
D843A22E7243A0FE00A27402437FA264224331A27F6F43A225
D043A2266243A0FE00A26C02434FA264224321A27F6743A22D
D843A2266243A0FE00B26402431FA26C224320A27F6F43A225
D843A2266243A0FE00A26402431FA26422437EA27F6F43A225
D043A2266243B0FE00A26C02431FA26C324320A27F7743A225
D043A2266243A0FE00A26402433FA26C224320A27F6743A225
D843A2266243A0FE00A264024330A274224325A27F6743A22D
C843A22E6243A0FE00A201FC43A27F8743A22DD8
6300CEC630A5A0FE00A2C18143A27F8743A22DD86300C6C630B5A0003EA1004086820540AF00A10003A000
018682044000A0FE00A0003EA1004086820540A700A000008200A100024000A0003AA100408E820540
03010D400002A0FE00A2019F4386A27F4F43A22DC863
00C6CE38A584A0FE00A2640243C1A264224339A27F6743B225
D843A2266243A0FE00A2740243FEA26422439FA27F6743A225
D843A22E6243A0FE00A26402433FA26C224373A27F6743B225
D843A2366243A0FE00A26402430EA26422437BA27F6F43A225
D043A2266243A0FE00A2640243C0A26422433AA27F6743A235
D843A22E7243A0FE00A264024331A264224347A27F6F43A225
D043A2266243A0FE00A26402431DA264224363A27F6743A22D
D843A2266243B0FE00A264024318A264224325A27F6F43A225
C843A2266243A0FE00A2640243F0A26422432CA27F6743A22D
D843A2266243A0FE00A26C0243FFA26C32439FA27F6743A22D
D843A2266243A0FE00A26402431AA26422431AA27F6743A225
D043A22E7243A0FE00A26C0243A3A26C3243C5A27F6743A225
D043A2266243A0FE00A26C0243E2A26C2243D9A27F6F43A225
D843A2266243A0FE00A2740243C1A2742243DCA27F6743A22D
C843A22E6243A0FE00A264024340A2642243A0A27F6F43A225
D043A2266243A0FE00B26C024382A26C324365A27F7743A225
D043A22E6243A0FE00A26C024340A26C224362A27F6743A225
D043A22E6243A0FE00A274024361A26422437AA27F6F43A225
D043A2266243A0FE00A264024362A264224361A27F6743A225
D843A2266243A0FE00A26402437AA26422436DA27F6F43A225
D843A2266243A0FE00A264024367A26422431AA27F6743A22D
C843A22E6243A0FE00A264024300A26C32435AA27F7743A225
D043A2266243A0FE00A26402435AA264224352A27F6743A225
D043A2266243A0FE00A264024352A27422435AA27F6743A22D
C843A2266243A0FE00A26402435AA26422434AA27F6F43A225
D043A2266243A0FE00A26402435AB264224352B27F6743A225
D043A22E6243A0FE00A26C02435AA26422434AA27F6F43A225
D043A2266243A0FE00A26402434AA26422435AA27F6743A22D
D843A2366243A0FE00A264024352A26422435AA27F6743A225
D043A2266243A0FE00A26C02435AA26C22435AA27F6743A225
D043B2266243A0FE00A26402435AA264224352A27F6F43A225
D843A22E6243A0FE00A26402434AA264224352B27F6743A235
D843B2266243A0FE00A201FC43A27F8F43A225C8
6300C6CE38A5A0FE00A2C18143A27F8743A225D86300CEC638A5B0003EA100408E820540B700A10003A000
0186820C4000A0FE00A0003EA1004086820D40A700A000008200A100024000A00032A1004086820540
03010D408002A0FE00B2019F438EB27F4743A225D073
00C6C638A58CA0FE00B264024352B264224352B27F6743A22D
D843A2266243A0FE00A264024352A264224352A27F6743A225
D043A2266243A0FE00A26C024352B26422435AB27F6743A225
D843A2266243A0FE00A264024352A264224300A27F6743A225
D843A22E6243A0FE00A264024340A2742243BDA27F6F43A225
D843A22E6243A0FE00A26402434AA264224363A27F6F43A225
D043A2266243A0FE00A264024308A26C3243E0A27F7743A22D
D843A22E7243A0FE00A26C024351A26C2243BDA27F6743A225
D043A22E6243A0FE00A264024341A264224323A27F6F43A225
D843A22E6243A0FE00A264024366A26C2243E7A27F6743A225
D843A2266243A0FE00A26C024361A26C224321A27F6F43B225
D843A2266243A0FE00A264024361A264224323A27F6743A225
D043A2266243A0FE00A264024320A264224302B27F6743A235
D843A2266243A0FE00A26C024392A26C224301A27F6743A225
D843A2266243A0FE00A264024300A264224380A27F6F43A225
D843A2266243A0FE00A2640243BCA264224301A27F6F43A225
D043A2266243A0FE00A2640243FCA264224301A27F6F43A225
D043A2266243B0FE00A26C0243C7A26C22435FA27F6743A225
D843A2266243A0FE00A26C0243E1A264224321A27F6743A225
D843B2266243A0FE00A2640243F7A264224343A27F6F43A225
D043A2266243A0FE00A2640243C1A2642243E7A27F6F43A225
D043A2266243A0FE00A26C024362A26C224327A27F6743A225
D043A22E6243A0FE00A26402430CA264224380A27F6743A22D
C843A2266243B0FE00A26C0243FCA264224321A27F6743A22D
D843A2266243A0FE00A2640243DDA26C224323A27F6743A225
D043A22E7243A0FE00A26C0243E0A264224303A27F6F43A225
D043A2266243A0FE00A2640243C2A264224321A27F6743A22D
D843A2266243A0FE00A26C02435EA264224327A27F6743A225
D043A22E6243A0FE00A26C02437FA26422430FA27F6F43A225
D843A2266243A0FE00A264024398A26C3243E3A27F7743A225
D043A2266243A0FE00A264024318A26422432DA27F6743A225
D843A2266243A0FE00A2640243C1A264224339A27F6F43B225
D043A2266243A0FE00A201FC43A27F8743A225D0
6300C6C638A5A0FE00A2C18143A27F8F43A225

D06300C6C638A5A0003EA100408E820 
540A700A10003A0000186820 
440000700C6C630A5F0000186A00000A10040820 
140C1390000810000000000000000000400000000000020 400080020 3013100B000A0003EA1004086820540B
D00A000008200A1000240BFA0003EA1004086820
540BE00A000008200A100024002A0003EB100408E820540BF00A00000820 0A100024000A00000A10040868205
40C13900008100000000000000000004000000000000 204000800203012100B80081A10053A00000600000C6CE38A5E0005C86A00000A100408 20140000000008100000000000000000004000000000000 20400080022600BF029802A00000A100408682054000000000810000000000000000000C00000000000020400080022600BF02900280A000536000

66 E6 18 55 F0 00 
BF 46
D00000
D10020C20120 000000004100000000000000008004000000000000102000
D00096000C004802
D0001E
D1002046C20520 5D00
D00000C200
D100022057
D0001E
D1002046C20520 5E00
D00000C200
D100022002
D0001E
D1002046C20520 5F00
D00000C200
D100022080
D0001E
D1002046C20520 5802
D00000C200
D100042000
D2
D0001E
D1002046C20520 5902
D00000C200
D1000220
D2
D0001E
D1002046C20520 5802
D00000C200
D100022000
D0001E
D1002046C20520 5A02
D00000C200
D1000420025F
D0001E
D1002046C20520 5500
D00000C200
D100022020
D0001E
D1002046C20520 5B00
D00000C200
D100022000
D0001E
D1002046C20520 5A00
D00000C200
D100022000
D0001E
D1002046C20520 3500
D00000C200D10002
2000

#endif